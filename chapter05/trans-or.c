#include <stdio.h>

/* Максимален брой върхове в графа */
#define MAXN 150

/* Брой върхове в графа */
const unsigned n = 6;
/* Матрица на съседство на графа */
int A[MAXN][MAXN] = {
  { 0, 1, 0, 0, 0, 1 },
  { 1, 0, 1, 0, 0, 0 },
  { 0, 1, 0, 1, 0, 0 },
  { 0, 0, 1, 0, 1, 0 },
  { 0, 0, 0, 1, 0, 1 },
  { 1, 0, 0, 0, 1, 0 }};

/* // пример за транзитивно неориентируем граф
   const unsigned n = 5;
   int A[MAXN][MAXN] = {
     { 0, 1, 0, 0, 1},
     { 1, 0, 1, 0, 0},
     { 0, 1, 0, 1, 0},
     { 0, 0, 1, 0, 1},
     { 1, 0, 0, 1, 0}};
 */

char trOrient(void)
{ /* намира броя на ребрата в графа */
  unsigned i, j, k, r, tr = 0;
  char flag;
  for (i = 0; i < n - 1; i++)
    for (j = i + 1; j < n; j++)
      if (A[i][j]) tr++;

  r = 0;
  do {
    for (i = 0; i < n; i++) { /* стъпка 1 – ориентираме произволно ребро (i,j) */
      for (j = 0; j < n; j++)
        if (1 == A[i][j]) {
          A[i][j] = 2;
          A[j][i] = -2;
          break;
        }
      if (j<n) break;
    }

    /* прилагаме правило 1) и 2), докато е възможно */
    do {
      flag = 0;
      for (i = 0; i < n; i++) {
        for (j = 0; j < n; j++) {
          if (2 == A[i][j]) {
            for (k = 0; k < n; k++) {
              if (i != k && j != k) {
                if (0 == A[i][k] || A[i][k] < -2) { /* случай 2.1) */
                  /* a) -> графът е транзитивно неориентируем */
                  if (2 == A[j][k]) return 1;
                  /* b) -> ориентираме реброто (j,k) */
                  if (1 == A[j][k]) { A[k][j] = 2; A[j][k] = -2; flag = 1; }
                }
                if (0 == A[j][k] || A[j][k] < -2) { /* случай 2.2) */
                  /* a) -> графът е транзитивно неориентируем */
                  if (2 == A[k][i]) return 1;
                  /* b) -> ориентираме реброто (j,k) */
                  if (1 == A[i][k]) { A[i][k] = 2; A[k][i] = -2; flag = 1; }
                }
              }
            }
          }
        }
      }
    } while (flag);

    /* стъпка 3 – изключваме ориентираните ребра от графа */
    for (i = 0; i < n; i++)
      for (j = 0; j < n; j++)
        if (2 == A[i][j]) {
          A[i][j] = -3; A[j][i] = -4; r++;
        }
  } while (r < tr);

  /* повтаряме, докато всички ребра от графа бъдат ориентирани */
  return 0;
}

void printGraph(void)
{ unsigned i, j;
  printf("Транзитивната ориентация е: \n");
  for (i = 0; i < n; i++) {
    for (j = 0; j < n; j++)
      if (-3 == A[i][j]) printf("  1");
        else (-4 == A[i][j]) ? printf(" -1") : printf("  0");
    printf("\n");
  }
}

int main(void) {
  if (trOrient())
    printf("Графът е транзитивно неориентируем! \n");
  else
    printGraph();
  return 0;
}
